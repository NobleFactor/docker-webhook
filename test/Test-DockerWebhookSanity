#!/usr/bin/env bash

########################################################################################################################
# SPDX-FileCopyrightText: 2016-2025 Noble Factor
# SPDX-License-Identifier: MIT
########################################################################################################################

# webhook_sanity - runtime sanity test for Noble Factor webhook images

source "$(dirname "$0")/../bin/Declare-BashScript" "$0" "help,keep,wait:" "h" "$@"

###########
# Arguments
###########

declare -r synopsis="Test-DockerWebhookSanity [--wait N] [--keep] [--help] [image:tag]"
eval set -- "$script_arguments"

[[ $* != -- ]] || usage "$synopsis"

declare -r default_image="noblefactor/webhook:1.0.0-preview.1"
declare keep=false
declare wait_seconds=2

while :; do
    case $1 in
        -h|--help)
            usage "$synopsis"; # does not return
            shift 1
            ;;
        --keep)
            keep=true
            shift 1
            ;;
        --wait)
            wait_seconds="$2"
            shift 2
            ;;
        --)
            shift 1
            break
            ;;
        *)
            error 1 "Unrecognized option: $1"
            ;;
    esac
done

image=${1:-${default_image}}
container_name=webhook-sanity-$$

###########
# Main
###########

# check required tools
command -v docker >/dev/null 2>&1 || {
    echo "ERROR: docker is not installed or not in PATH"
    exit 2
}

echo "[sanity] Image: $image"

# Ensure artifacts directory exists for captured logs
mkdir -p "$(dirname "$0")/artifacts" >/dev/null 2>&1 || true
timestamp=$(date -u +%Y%m%dT%H%M%SZ)
logfile="$(dirname "$0")/artifacts/docker-logs-${timestamp}.log"

# Use Make targets exclusively to generate and start the webhook image/container.
echo "[sanity] Running: make clean New-Webhook (output appended to $logfile)"
printf '\n=== make clean New-Webhook output (%s) ===\n' "$(date -u +%Y%m%dT%H%M%SZ)" >> "$logfile"
make clean New-Webhook 2>&1 | tee -a "$logfile"
rc=${PIPESTATUS[0]:-0}
if [[ "$rc" -ne 0 ]]; then
    echo "ERROR: 'make clean New-Webhook' failed. Ensure Makefile targets are present and working."
    exit 3
fi

echo "[sanity] Running: make Start-Webhook (output appended to $logfile)"
printf '\n=== make Start-Webhook output (%s) ===\n' "$(date -u +%Y%m%dT%H%M%SZ)" >> "$logfile"
make Start-Webhook 2>&1 | tee -a "$logfile"
rc=${PIPESTATUS[0]:-0}
if [[ "$rc" -ne 0 ]]; then
    echo "ERROR: 'make Start-Webhook' failed. Ensure Makefile Start-Webhook target is present and works."
    exit 3
fi

# Locate a running container that was started from the image

container_id=$(docker ps --filter "ancestor=$image" --format '{{.ID}}' | head -n 1)

if [[ -z "$container_id" ]]; then
    echo "ERROR: could not find a running container started from image '$image' after make Start-Webhook"
    exit 3
fi

container_name=$(docker ps --filter "id=$container_id" --format '{{.Names}}' | head -n1)
echo "[sanity] Using container $container_name (id: $container_id) started from $image"

echo "[sanity] Waiting up to ${wait_seconds}s (polling) for service to initialize..."
end_time=$((SECONDS + wait_seconds))
logs=''

while (( SECONDS <= end_time )); do
    logs=$(docker logs --tail 2000 "$container_name" 2>&1 || true)
    printf '%s
' "$logs" > "$logfile"
    # Quick checks for success markers
    if printf '%s' "$logs" | grep -iq "serving hooks"; then
        echo "[sanity] SUCCESS: webhook started and serving hooks detected in logs."
        echo "[sanity] Full logs saved to: $logfile"
        # cleanup only when not asked to keep artifacts
        if [[ "${keep:-false}" != true ]]; then
            echo "[sanity] Running: make clean (output appended to $logfile)"
            printf '\n=== make clean output (%s) ===\n' "$(date -u +%Y%m%dT%H%M%SZ)" >> "$logfile"
            make clean 2>&1 | tee -a "$logfile" || true
        else
            echo "[sanity] --keep specified; leaving container and artifacts in place: $container_name, $logfile"
        fi
        exit 0
    fi
    if printf '%s' "$logs" | grep -iq "version [0-9]\+\.[0-9]"; then
        echo "[sanity] INFO: webhook binary started (version found in logs), but 'serving hooks' text not matched. Check logs at: $logfile"
        if [[ "${keep:-false}" != true ]]; then
            echo "[sanity] Running: make clean (output appended to $logfile)"
            printf '\n=== make clean output (%s) ===\n' "$(date -u +%Y%m%dT%H%M%SZ)" >> "$logfile"
            make clean 2>&1 | tee -a "$logfile" || true
        else
            echo "[sanity] --keep specified; leaving container and artifacts in place: $container_name, $logfile"
        fi
        exit 0
    fi
    sleep 1
done

echo
echo "[sanity] Container status:"
docker ps --filter "name=$container_name" --format 'table {{.ID}}\t{{.Image}}\t{{.Status}}' || true

echo
echo "[sanity] Capturing final logs (last 2000 lines) to $logfile:"
logs=$(docker logs --tail 2000 "$container_name" 2>&1 || true)
printf '%s
' "$logs" > "$logfile"
printf '%s
' "$logs"

echo
echo "[sanity] Inspecting runtime files inside the container (best-effort):"
docker exec "$container_name" bash -c '
    set -o errexit -o nounset -o pipefail
    printf "== /init ==\n";
    if [[ -e /init ]]; then ls -l /init; else printf "/init not found\n"; fi;
    printf "\n== /command ==\n";
    if [[ -d /command ]]; then ls -l /command | sed -n "1,200p"; else printf "/command not found\n"; fi;
    printf "\n== /package/admin ==\n";
    if [[ -d /package/admin ]]; then ls -l /package/admin | sed -n "1,200p"; else printf "/package/admin not found\n"; fi;
' || true

echo
echo "[sanity] WARNING: could not find clear 'serving hooks' or version markers in logs. Full logs written to: $logfile"
if [[ "${keep:-false}" = true ]]; then
    echo "[sanity] --keep specified; leaving container and artifacts in place: $container_name, $logfile"
else
    echo "[sanity] Leaving artifacts in place for inspection (test failed). To cleanup run: make clean"
fi
exit 1
