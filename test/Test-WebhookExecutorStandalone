#!/usr/bin/env bash

########################################################################################################################
# SPDX-FileCopyrightText: 2016-2025 Noble Factor
# SPDX-License-Identifier: MIT
########################################################################################################################

# Test-WebhookExecutorStandalone - Test webhook-executor binary directly
# shellcheck source=../bin/Declare-BashScript

source "$(dirname "$0")/../bin/Declare-BashScript" "$0" "help,command:,location:,token-name:,service-principal-password:,service-principal-name:" "h" "$@"

###########
# Functions
###########

function test_command {
    local address="$1"
    local cmd="$2"

    note "==> Testing command: $cmd"

    local response=$(cd src && go run ./cmd/webhook-executor --destination "$address" --command "$cmd" --authorization "$jwt")

    if [[ -z "$response" ]]; then
        error 0 "FAIL: No response for $cmd"
        return 1
    fi

    if ! echo "$response" | jq -e '.status and .reason and (.error == null or type == "string") and has("stdout") and has("stderr") and has("correlationId")' >/dev/null 2>&1; then
        error 0 "FAIL: Invalid response for $cmd: $response"
        return 1
    fi

    success "PASS: $cmd returned: $response"
    return 0
}

function wait_for_container_and_user {

    local container="$1"
    local user="$2"
    local timeout="${3:-60}"
    local end="$(($(date +%s) + timeout))"

    while (($(date +%s) < end)); do
        local cid
        cid=$(docker ps --filter "name=$container" --filter "status=running" -q 2>/dev/null) || cid=""
        if [[ -n "$cid" ]] && docker exec "$container" id "$user" >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
    done

    error 1 "timed out waiting for ${container}/${user}"
}

###########
# Arguments
###########

declare -r synopsis="${script_name} --help | --location LOCATION --token-name TOKEN_NAME --destination DESTINATION [--service-principal-name NAME] [--service-principal-password PASSWORD] --command CMD [--command CMD ...]"
eval set -- "$script_arguments"
declare -a commands=()

while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
        usage "$synopsis"
        ;;
    --command)
        commands+=("$2")
        shift 2
        ;;
    --location)
        declare -r location="$2"
        shift 2
        ;;
    --service-principal-name)
        declare -r service_principal_name="$2"
        shift 2
        ;;
    --service-principal-password)
        declare -r service_principal_password="$2"
        shift 2
        ;;
    --token-name)
        declare -r token_name="$2"
        shift 2
        ;;
    --)
        shift
        break
        ;;
    *)
        error 1 "Unrecognized option: $1"
        ;;
    esac
done

((${#commands[@]} > 0)) || error 1 "At least one command to test is required."
[[ -n ${location:-} ]] || error 1 "A non-blank value for location is required."
[[ -n ${service_principal_name:-} ]] || error 1 "A non-blank value for service-principal-name is required."
[[ -n ${service_principal_password:-} ]] || error 1 "A non-blank value for service-principal-password is required."
[[ -n ${token_name:-} ]] || error 1 "A non-blank value for token-name is required."

# Fetch AZURE_CLIENT_ID and AZURE_TENANT_ID from current az login

export AZURE_CLIENT_SECRET="${service_principal_password:-}"
export AZURE_CLIENT_ID=$(az ad sp list --display-name "$service_principal_name" --query [0].appId -o tsv 2>/dev/null || echo "")
export AZURE_TENANT_ID=$(az ad sp list --display-name "$service_principal_name" --query [0].appOwnerOrganizationId -o tsv 2>/dev/null || echo "")

if [[ -z "${AZURE_CLIENT_SECRET:-}" || -z "$AZURE_CLIENT_ID" || -z "$AZURE_TENANT_ID" ]]; then
    error 1 "Unable to retrieve AZURE_CLIENT_SECRET, AZURE_CLIENT_ID, or AZURE_TENANT_ID from az ad sp list. Ensure service-principal name '${service_principal_name}' is the correct display name and you have permissions to query service principals."
fi

# Set webhook config directory location

cd "${script_root}/.." && declare -r webhook_config=$(/bin/realpath "webhook.config/$location")

# Source hooks environment

declare -r hooks_env="${webhook_config}/hooks.env"

if [[ ! -f "$hooks_env" ]]; then
    error 1 "Hooks environment file not found: $hooks_env"
fi

source "$hooks_env"

# Fetch the JSON Web Token from Azure Key Vault

declare -r vault_name=$(echo "$WEBHOOK_KEYVAULT_URL" | sed 's|https://||' | sed 's|\.vault\.azure\.net.*||')
declare -r jwt=$(az keyvault secret show --vault-name "$vault_name" --name "$token_name" --query value -o tsv)

if [[ -z "$jwt" ]]; then
    error 1 "Failed to fetch JSON Web Token from Azure Key Vault"
fi

###########
# Main
###########

declare -r authorized_key="$(cat "${webhook_config}/ssh/id_rsa.pub")"
declare -r destination=webhook-executor-destination

note "Starting test container: ${destination}..."

if [[ -n $(sudo docker ps -a --filter name=${destination} --format "{{.Names}}") ]]; then
    sudo docker container rm --force "${destination}"
fi

if [[ -z $(sudo docker images -q noblefactor/${destination}) ]]; then
    sudo docker build -t "noblefactor/${destination}" -f "Dockerfile.${destination}" .
fi

sudo docker run -d --name "${destination}" "noblefactor/${destination}" "${authorized_key}"
wait_for_container_and_user ${destination} ${destination} 60

declare -r destination_address="ssh://${destination}@$(
    docker inspect --format='{{.NetworkSettings.IPAddress}}' ${destination}
):$(
    docker inspect --format='{{.Config.ExposedPorts}}' "${destination}" | awk -F'[][/:]' '{print $2}'
)"

# Ensure that webhook-executor can locate its location-based configuration

export WEBHOOK_CONFIG="${webhook_config}"

# Run test commands

declare -r start_time=$(date +%s)

note "Starting standalone webhook-executor tests for destination: $destination"
passed_tests=0
failed_tests=0

for command in "${commands[@]}"; do
    if test_command "${destination_address}" "$command"; then
        ((passed_tests++)) || :
    else
        ((failed_tests++)) || :
    fi
done

declare -r end_time=$(date +%s)
declare -r elapsed=$((end_time - start_time))

note "Test Run Complete:
Status: [$passed_tests Passed, $failed_tests Failed]
Duration: ${elapsed}s"
