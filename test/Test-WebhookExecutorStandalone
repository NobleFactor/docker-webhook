#!/usr/bin/env bash

########################################################################################################################
# SPDX-FileCopyrightText: 2016-2025 Noble Factor
# SPDX-License-Identifier: MIT
########################################################################################################################

# Test-WebhookExecutorStandalone - Test webhook-executor binary directly
# shellcheck source=../bin/Declare-BashScript

source "$(dirname "$0")/../bin/Declare-BashScript" "$0" "help,command:,location:" "h" "$@"

###########
# Functions
###########

function test_command {
    local address="$1"
    local cmd="$2"

    note "==> Testing command: $cmd"

    local response=$(cd src && go run ./cmd/webhook-executor --destination "$address" --command "$cmd" --authorization "$auth_token")

    if [[ -z "$response" ]]; then
        error 0 "FAIL: No response for $cmd"
        return 1
    fi

    if ! echo "$response" | jq -e '.status and .reason and (.error == null or type == "string") and has("stdout") and has("stderr") and has("authToken") and has("correlationId")' >/dev/null 2>&1; then
        error 0 "FAIL: Invalid response for $cmd: $response"
        return 1
    fi

    success "PASS: $cmd returned: $response"
    return 0
}

###########
# Arguments
###########

declare -r synopsis="${script_name} --help | --location LOCATION --command CMD [--command CMD ...]"
eval set -- "$script_arguments"

while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
        usage "$synopsis"
        ;;
    --command)
        commands="$2"
        shift 2
        ;;
    --location)
        location="$2"
        shift 2
        ;;
    --)
        shift
        break
        ;;
    *)
        error 2 "Unrecognized option: $1"
        ;;
    esac
done

[[ -n ${commands:-} ]] || error 2 "A semicolon-separated list of test commands is required."
declare -r commands

[[ -n ${location:-} ]] || error 2 "A value for location is required."
declare -r location

###########
# Main
###########

# Source service environment so that webhook-executor sees the environment it has when running in is container

cd "${script_root}/.." && declare -r webhook_config=$(realpath "webhook.config/$location")
declare -r service_env="${webhook_config}/service.env"

if [[ ! -f "$service_env" ]]; then
    error 1 "Service environment file not found: $service_env"
fi

source "$service_env"

# Ensure we've got a fresh authorization token

declare -r auth_token="$("${script_root}/../bin/New-WebhookExecutorToken" --silent --env-file "${service_env}")"

# Fetch AZURE_CLIENT_SECRET from key vault and create a new auth token

declare -r vault_name=$(echo "$WEBHOOK_KEYVAULT_URL" | awk '{ gsub(/https:\/\//, ""); sub(/\.vault\.azure\.net.*/, ""); print }')
export AZURE_CLIENT_SECRET="$(az keyvault secret show --vault-name "$vault_name" --name "$WEBHOOK_AZURE_CLIENT_NAME-password" --query value -o tsv)"

# Ensure that webhook-executor can find its location-based configuration

export WEBHOOK_CONFIG="${webhook_config}"

# Start the test container

declare -r destination="$("${script_root}/Start-WebhookExecutorTestContainer" --location "${location}")"

# Run test commands

declare -r start_time=$(date +%s)

note "Starting standalone webhook-executor tests for destination: $destination"
passed_tests=0
failed_tests=0

while IFS= read -r line; do
    if [[ -n ${line:-} ]]; then
        if test_command "${destination}" "$line"; then
            ((passed_tests++)) || :
        else
            ((failed_tests++)) || :
        fi
    fi
done < <(printf '%s' "$commands" | awk 'BEGIN { RS = "[[:space:]]*;[[:space:]]*" } { print $0 }')

declare -r end_time=$(date +%s)
declare -r elapsed=$((end_time - start_time))

note "==> Test Complete: Test-WebhookExecutorStandalone - Status: [$passed_tests Passed, $failed_tests Failed] Duration: ${elapsed}s"

if ((failed_tests > 0)); then
    exit 1
fi
